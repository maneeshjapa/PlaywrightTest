"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jest_runner_1 = __importDefault(require("jest-runner"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const coverage_1 = require("./coverage");
const getBrowserTest = ({ test, config, browser, wsEndpoint, device, }) => {
    const { displayName, testEnvironmentOptions } = test.context.config;
    const playwrightDisplayName = utils_1.getDisplayName(browser, device);
    return {
        ...test,
        context: {
            ...test.context,
            config: {
                ...test.context.config,
                testEnvironmentOptions: {
                    ...testEnvironmentOptions,
                    [constants_1.CONFIG_ENVIRONMENT_NAME]: config,
                },
                browserName: browser,
                wsEndpoint,
                device,
                displayName: {
                    name: displayName
                        ? `${playwrightDisplayName} ${typeof displayName === 'string' ? displayName : displayName.name}`
                        : playwrightDisplayName,
                    color: 'yellow',
                },
            },
        },
    };
};
const getDevices = (devices, availableDevices) => {
    let resultDevices = [];
    if (devices) {
        if (devices instanceof RegExp) {
            resultDevices = Object.keys(availableDevices).filter((item) => item.match(devices));
        }
        else {
            resultDevices = devices;
        }
    }
    return resultDevices;
};
class PlaywrightRunner extends jest_runner_1.default {
    constructor(globalConfig, context) {
        const config = { ...globalConfig };
        // Set default timeout to 15s
        config.testTimeout = config.testTimeout || constants_1.DEFAULT_TEST_PLAYWRIGHT_TIMEOUT;
        super(config, context);
        this.browser2Server = {};
    }
    async launchServer(config, wsEndpoint, browser, instance) {
        const { launchType, launchOptions, skipInitialization } = config;
        if (!skipInitialization || (launchType === constants_1.SERVER && wsEndpoint === null)) {
            if (!this.browser2Server[browser]) {
                const options = utils_1.getBrowserOptions(browser, launchOptions);
                this.browser2Server[browser] = await instance.launchServer(options);
            }
        }
        return wsEndpoint || this.browser2Server[browser].wsEndpoint();
    }
    async getTests(tests, config) {
        const { browsers, devices, connectOptions, useDefaultBrowserType } = config;
        const pwTests = [];
        for (const test of tests) {
            if (useDefaultBrowserType) {
                const { devices: availableDevices, instance } = utils_1.getPlaywrightInstance();
                const resultDevices = getDevices(devices, availableDevices);
                const browserTest = {
                    test: test,
                    config,
                };
                if (resultDevices.length) {
                    for (const device of resultDevices) {
                        const browser = typeof device === 'string'
                            ? availableDevices[device].defaultBrowserType
                            : constants_1.CHROMIUM;
                        const wsEndpoint = await this.launchServer(config, (connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.wsEndpoint) || null, browser, instance[browser]);
                        if (typeof device === 'string') {
                            const availableDeviceNames = Object.keys(availableDevices);
                            utils_1.checkDeviceEnv(device, availableDeviceNames);
                        }
                        pwTests.push(getBrowserTest({ ...browserTest, browser, wsEndpoint, device }));
                    }
                }
            }
            else {
                for (const browser of browsers) {
                    utils_1.checkBrowserEnv(browser);
                    const { devices: availableDevices, instance } = utils_1.getPlaywrightInstance(browser);
                    const resultDevices = getDevices(devices, availableDevices);
                    const wsEndpoint = await this.launchServer(config, (connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.wsEndpoint) || null, browser, instance);
                    const browserTest = {
                        test: test,
                        config,
                        wsEndpoint,
                        browser,
                    };
                    if (resultDevices.length) {
                        resultDevices.forEach((device) => {
                            if (typeof device === 'string') {
                                const availableDeviceNames = Object.keys(availableDevices);
                                utils_1.checkDeviceEnv(device, availableDeviceNames);
                            }
                            pwTests.push(getBrowserTest({ ...browserTest, device }));
                        });
                    }
                    else {
                        pwTests.push(getBrowserTest({ ...browserTest, device: null }));
                    }
                }
            }
        }
        return pwTests;
    }
    async runTests(tests, watcher, onStart, onResult, onFailure, options) {
        const { rootDir, testEnvironmentOptions } = tests[0].context.config;
        const config = await utils_1.readConfig(rootDir, testEnvironmentOptions[constants_1.CONFIG_ENVIRONMENT_NAME]);
        const browserTests = await this.getTests(tests, config);
        if (config.collectCoverage) {
            await coverage_1.setupCoverage();
        }
        await (options.serial
            ? this['_createInBandTestRun'](browserTests, watcher, onStart, onResult, onFailure)
            : this['_createParallelTestRun'](browserTests, watcher, onStart, onResult, onFailure));
        for (const browser in this.browser2Server) {
            await this.browser2Server[browser].close();
        }
        if (config.collectCoverage) {
            await coverage_1.mergeCoverage();
        }
    }
}
exports.default = PlaywrightRunner;
